# 深入理解计算机系统

## 计算机漫游

**编译系统**

先将一个hello程序转化为可执行程序hello.c。

这个生成可执行程序的过程是复杂的，大概分为4步，分别为 **预处理、编译、汇编和链接**。

![603b9dc641357b0243e9c984b79da64](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\603b9dc641357b0243e9c984b79da64.png)

**预处理**

预处理器会根据以#开头的代码，来修改原始程序。例如hello程序中引入了头文件stdio.h，预处理器会读取该头文件中的内容，将其中的内容直接插入到源程序中，结果就得到了另一个C程序。即：hello.c经过预处理器后得到文本文件hello.i。

**编译**

编译器将hello.i文件翻译成hello.s文件，这一阶段包括词法分析、语法分析、语义分析、中间代码生成以及优化等等一系列的中间操作。

**汇编**

汇编器根据指令集将汇编程序hello.s翻译成机器指令，并把这一系列的机器指令按照固定的规则进行打包，得到可重定位目标文件hello.o。此时hello.o虽然是一个二进制的文件，但还是不能执行，还要经历最后一个阶段：链接。

**链接**

在hello这个程序中，我们调用了printf函数，这个函数是标准C库中的一个函数，存储在名为printf.o的文件中。连接器（ld）负责把hello.o和printf.o按照一定规则进行合并。正是因为链接器要对hello.o和printf.o的进行调整，所以hello.o才会被称之为可重定位目标文件。最终经过链接阶段可以得到可执行目标文件hello。

**了解编译系统如何工作**

了解编译系统的工作有很大益处：

1.理解编译系统可以优化程序的性能

+ 现代编译器是非常成熟的工具，通常可以生成很好的代码，作为一个程序员， 我们没有必要为了写出高效的代码，而去研究编译器的内部是如何工作的，但 是，我们还是需要对机器执行的代码有一个基本的了解，这样我们就知道编译 器把不同的 C 代码转换成的机器代码是什么。

+ 我们在写代码的时候可能会有这样的困惑，或者面试中会被问到以下类似的问 题：

+ 例如：一个 switch 语句是不是要比一连串的 if-else 要高效的多？个函数调用的 开销有多大？while 循环比 for 循环更高效么？

2.理解编译系统可以帮助我们理解链接过程中出现的错误

+ 如果所有的程序都像 helloworld 一样简单，那的确没有必要去理解编译系统， 但是当你试图去构建大型程序的时候，往往涉及到各种函数库的调用，根据以 往的经验，一些奇奇怪怪的错误往往都是与链接器有关的。 
+ 例如：静态变量和全局变量的区别是什么？静态库和动态库的区别是什么？ 
+ 更严重的是，还有一些链接错误直到程序运行的时候才会出现。

3.避免安全漏洞

+ 多年以来，缓冲区溢出（buffer overflow）是导致互联网安全漏洞的主要原因， 如何避免写出的代码存在安全漏洞，第一步就是要理解数据和控制信息在程序 栈上是如何存储的，了解不严谨不规范的书写方式会引起什么样的后果。

**硬件架构图**

![cff1ee0c7860475f2be7339a35586da](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\cff1ee0c7860475f2be7339a35586da.png)

**CPU架构**

CPU:

中央处理单元（Central Processing Unit），也称处理器，包含PC（程序计数器：Program Count）、寄存器堆（Register file）、ALU（算数/逻辑计算单元：Arithmetic/logic Unit）三个部分。

CPU内部结构含义

+ **程序计数器PC**：是一个 4 字节或是 8 字节的存储空间，里面存放的是某一条 指令的地址。从系统上电的那一瞬间，直到系统断电，处理器就不断地在执行 PC 指向的指令，然后更新 PC，使其指向下一条要执行的指令（注意：这个下 一条指令与刚刚执行的指令不一定是相邻的）
+ **寄存器：**可以理解为一个临时存放数据的空间。例如计算两个变量 a+b 的和， 处理器从内存中读取 a 的值暂存在寄存器 X 中，读取 B 的值暂存在寄存器 Y 中，这个操作会覆盖寄存器中原来的数值，处理器完成加载的操作后，ALU （Arithmatic/logic Unit）会从复制寄存器 X 和 Y 中保存的数值，然后进行算术 运算，得到的结果会保存到寄存器 X 或者寄存器 Y 中，此时寄存器中原来的数 值会被新的数值覆盖。
+ **算数/逻辑计算单元 ALU：**计算速度极快，且专攻算数与逻辑的计算，计算机核心部分。

**内存**

主存（Main Memory），也称为内存、运行内存，处理器在执行程序时，内存主要存放程序指令以及数据。从物理上讲，内存是由随机动态存储芯片组成；从逻辑上讲，内存可以看成一个从0开始的大数组，每个字节都有相应地址。

**总线**

内存和处理器之间通过总线来进行数据传递。实际上，总线贯穿了整个计算机系统，它负责将信息从一个部件传递到另一个部件。通常总线被设计成传送固定长度的字节块，也就是字（word），至于这个字到底是多少个字节，各个系统中是不一样的，32位的机器，一个字长是4个字节；而64位的机器，一个字长是8个字节。

**输入和输出设备**

除了处理器，内存以及总线，计算机系统还包含了各种输入输出设备，例如键盘、 鼠标、显示器以及磁盘等等。每一个输入输出设备都通过一个控制器或者适配器与 IO 总线相连.

**区别：**控制器与适配器主要区别是在于它们的封装方式，无论是控制器还是适配器，它们 的功能都是在 IO 设备与 IO 总线之间传递数据.

hello**程序执行过程中发生了什么：**

操作过程：

hello.c经过编译系统得到可执行目标文件hello，此时可执行目标文件hello已经经存放在系统的磁盘上，那么，如何运行这个可执行文件呢？

 • 在 linux 系统上运行可执行程序：打开一个 shell 程序，然后在 shell 中输入相应 可执行程序的文件名：

 • linux>./hello

 **shell是什么**

 shell 是一个命令解释程序，如果命令行的第一个单词不是内置的 shell 命令，shell 就会对这个文件进行加载并运行. 此处，shell 加载并且运行 hello 程序，屏幕上显示 hello,world 内容，hello 程序运行结束并退出，shell 继续等待下一个命令的输入. 

**程序执行流程**

1 首先我们通过键盘输入”./hello” 的字符串，shell 程序会将输入的字符逐一读入 寄存器，处理器会把 hello 这个字符串放入内存中。 

2 当我们完成输入，按下回车键时，shell 程序就知道我们已经完成了命令的输入， 然后执行一系列的指令来来加载可执行文件 hello。 

3 这些指令将 hello 中的数据和代码从磁盘复制到内存。数据就是我们要显示输 出的”hello , world\n” ，这个复制的过程将利用 DMA（Direct Memory Access） 技术，数据可以不经过处理器，从磁盘直接到达内存。

 4 当可执行文件 hello 中的代码和数据被加载到内存中，处理器就开始执行 main 函数中的代码，main 函数非常简单，只有一个打印功能。

![49b237a341c7a98f66406d4efa43cb9](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\49b237a341c7a98f66406d4efa43cb9.png)

![278ce8b1b2e5c0ebd97f593f474e9bb](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\278ce8b1b2e5c0ebd97f593f474e9bb.png)

![5c0ffc9a5be243c63da13e0e14c909f](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\5c0ffc9a5be243c63da13e0e14c909f.png)

从 hello 程序执行的过程来看，系统即使执行如此简单的程序，数据信息仍旧需要在 磁盘、内存、处理器以及 IO 设备之间进行搬运。 数据从一个地方搬运到另外一个地方需要花费时间，系统设计人员的一个主要任务 就是缩短信息搬运所花费的时间。

**设备容量**

通常情况下，大容量的存储设备的存取速度要比小容量的慢，运行速度更快的设备 的价格相对于低速设备要更贵。例如：在一个系统上，磁盘的容量一般为 TB 级， 内存的容量一般为 GB 级，磁盘的容量大概是内存的 1000 倍。

**高速缓存（cache）至关重要**

对于处理器而言，从磁盘上读取一个字所花费的时间开销比从内存中读取的开销大 1000 万倍。寄存器文件的只能存储几百个字节的信息，而内存的可以存放几十亿的 字节信息（GB 级），从寄存器文件读取数据比从内存读取差不多要快 100 倍。

 随着半导体技术的发展，处理器与内存之间的差距还在持续增大，针对处理器和内 存之间的差异，系统设计人员在寄存器文件和内存之间引入了高速缓存（cache）， 比较新的，处理能力比较强的处理器，一般有三级高速缓存，分别为 L1 cache ，L2 cache 以及 L3 cache。

 L1 cache 的访问速度与访问寄存器文件几乎一样快，容量大小为数万字节（KB 级 别）；L2 cache 的访问速度是 L1 cache 的五分之一，容量大小为数十万到数百万字 节之间；L3 cache 的容量更大，同样访问速度与 L2 cache 相比也更慢。 

**存储设备的层次结构**

![70dcba810dfa21da9f3a761a44a51b5](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\70dcba810dfa21da9f3a761a44a51b5.png)

**操作系统的作用**

无论是 shell 程序还是 hello 程序都没有直接访问键盘、显示器、磁盘这些硬件设备， 真正操挫硬件的是操作系统，我们可以把操作系统看成是应用程序和硬件之间的中 间层，所有的应用程序对硬件的操作必须通过操作系统来完成。

这样设计的目的主要有两个：

1.防止硬件被失控的应用程序滥用；

2.操作系统提供统一的机制来控制这些复杂的底层硬件

为了实现上述的功能，操作系统引入了几个抽象的概念。例如：文件是对 IO 设备的 抽象；虚拟内存是对内存和磁盘 IO 的抽象；进程是对处理器、内存以及 IO 设备的 抽象。

**进程**

假设示例场景中只有两个并发的进程：shell 进程和 hello 进程

1.最开始的时候，只有 shell 进程在运行，即 shell 在等待命合行的输入。

2 当我们通过 shell 进程加载 hello 进程时，shell 进程通过系统调用来执行我们的 请求，系统调用会将控制权从 shell 进程传递给操作系统，操作系统保存 shell 进程的上下文，然后创建一个新的 hello 进程及其上下文，然后将控制权转交给 新的 hello 进程。

 3 hello 进程执行完之后，操作系统就会恢复 shell 进程的上下文，并将控制权交 给 shell 进程，之后 shell 进程继续等待下一个命令的输入。

 4 操作系统会跟踪进程运行所需要的所有状态信息，这种状态，称为上下文 （Context）。例如当前 PC 和寄存器的值，以及内存中的内容等等。

**进程角度**

![bbb863b5091364177252cf71bcf600a](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\bbb863b5091364177252cf71bcf600a.png)

![26e710936dbdbf46bea355942a37c3e](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\26e710936dbdbf46bea355942a37c3e.png)

**虚拟内存**

操作系统为每个进程提供了一个假象，就是每个进程都在独自占用整个内存空间， 每个进程看到的内存都是一样的，我们称之为虚拟地址空间.

![bfe33a343a1e44dca80bc45a4484c96](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\bfe33a343a1e44dca80bc45a4484c96.png)

• 第一个区域是用来存放程序的代码和数据的，这个区域的内容是从可执行目标 文件中加载而来的，例如我们多次提到的 hello 程序。对所有的进程来讲，代码 都是从固定的地址开始。至于这个读写数据区域放的是什么数据呢？例如在 C 语言中，全局变量就是存放在这个区域. 

• 顺着地址增大的方向，继续往上看就是堆（heap），学过 C 语言的同学应该用过 malloc 函数，程序中 malloc 所申请的内存空间就在这个堆中。程序的代码和数 据区在程序一开始的时候就被指定了大小，但是堆可以在运行时动态的扩展和 收缩.

• 接下来，就是共享库的存放区域。这个区域主要存放像 C 语言的标准库和数学 库这种共享库的代码和数据，例如 hello 程序中的 printf 函数就是存放在这里. 

• 继续往上看，这个区域称为用户栈（user stack），我们在写程序的时候都使用过 函数调用，实际上函数调用的本质就是压栈。这句话的意思是：每一次当程序 进行函数调用的时候，栈就会增长，函数执行完毕返回时，栈就会收缩。需要 注意的是 栈的增长方向是从高地址到低地址. 

• 最后，我们看一下地址空间的最顶部的区域，这个区域是为内核保留的区域， 应用程序代码不能读写这个区域的数据，也不能直接调用内核中定义的函数， 也就是说，这个区域对应用程序是不可见的.

**文件**

Linux系统的哲学思想是：一切皆文件。

• 所有的 IO 设备，包括键盘，磁盘，显示器，甚至网络，这些都可以看成文件， 系统中所有的输入和输出都可以通过读写文件来完成. 

• 虽然文件的概念非常简单，但却非常强大。例如︰当程序员需要处理读写磁盘 上的文件时，他们不需要了解具体的磁盘技术，同一个程序，可以在不同磁盘 技术上的不同系统上运行.

**系统之间利用网络通信**

系统看来，网络也可以视为一个IO设备。

• 随着互联网的发展，从一台计算机发送消息到另外一台计算机已经成为非常普 遍的应用。《深入理解计算机系统》中讲述了如何使用本地计算机上的 telnet 客 户端连接远程主机上的 telnet 服务器。

 • 由于 telnet 的安全性问题，目前 ssh 的连接方式的更加普遍。当我们在 ssh 的 客户端中输入 hello 字符串并且敲下回车之后，客户端的软件就会通过网络将 字符串发送到 ssh 服务端，ssh 服务端从网络端接收到这个字符串以后，会将这 个字符串传递给远程主机上的 shell 程序，然后 shell 负责 hello 程序的加载，运 行结果返回给 ssh 的服务端，最后 ssh 的服务端通过网络将程序的运行结果发 送给 ssh 的客户端，ssh 客户端在屏幕上显示运行结果。![0ea72272dcbd5989433d8a0c2b66787](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\0ea72272dcbd5989433d8a0c2b66787.png)

**一些约定**

• 任务 (task)：并行计算所处理的对象.

 • 工作量 (workload)：处理某任务的所需的各种开销的总和. 

• 处理器 (processor)：并行计算中所使用的最基本的处理器单元.

 • 执行率 (execution rat)：每个处理器单位时间能完成的工作量 .

 • 执行时间 (execution time)：处理某任务所需的时间. 

• 加速比 (scalability)：当处理器个数增多时，完成某固定工作量任务所需执行时 间的减少倍数.

 • 理想加速比 (ideal scalability)：处理器个数增多的比例. 

• 并行效率 (parallel efficiency): 加速比 ÷ 理想加速比 ×100%.![be0cacbc770b5dbd51bc424b8410c20](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\be0cacbc770b5dbd51bc424b8410c20.png)

## 信息的表述和处理

### 信息存储

**虚拟地址空间**

通常情况下，程序将内存视为一个非常大的数组，数组的元素是由一个个的字节组成，每个字节都由一个唯一的数字来表示，我们称为地址（address），这些所以的地址的集合就称为虚拟地址空间（virtual address space）.

**字数据大小**

字长决定了虚拟地址空间的最大的可以到多少，也就是说，对于一个字长为w位的机器，虚拟地址的范围是0到2**w-1。

• 近些年，高性能服务器、个人电脑以及智能手机已经完成了从 32 位字长到 64 位字长迁移。不过在一些嵌入式的应用场景中，32 位的机器仍旧占有一席之 地。对于 32 位的机器，虚拟地址空间最大为 4GB，而 64 位的机器，虚拟地址 空间最大为 16EB。

 • 在迁移的过程中，大多数 64 位的机器做了向后兼容，因此为 32 位机器编译的 程序也可以运行在 64 位机器上。在 64 位的机器上，可以通过这条命令编译生 成可以在 32 位机器上运行的程序。

 • linux> gcc -m32 -o hello32 hello.c • 通过修改编译选项，就可以编译生成在 64 位机器上运行的程序。

 • linux> gcc -m64 -o hello64 hello.c 

注意，hello32 既可以运行在 32 位机器上，也可以运行在 64 位机器上，但是 hello64 只能运行在 64 位的机器上。

 对于 32 位程序和 64 位程序，主要的区别还是在于程序是如何编译的，而不是运行机器的类型。

**寻址和字节顺序**

C语言中，支持整数和浮点数多种数据格式，下表列式了不同数据类型在32位机器与64位机器上所占字节数的大小。

![5414d52316e660b134d2e883c0a0157](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\5414d52316e660b134d2e883c0a0157.png)

从这个表中，我们可以看到很多数据类型都是占用了多个字节空间。对于我们需要存储的数据，我们需要搞清楚该数据的地址是什么，以及数据在内存中是如何排布的。

eg.一个int类型的变量下（0x01234567）,假设地址位于0x100处，由于int类型占4个字节，因此变量x被存储在地址为0x100,0x101,0x102,0x103的内存处。

+ 大端法：最高有效字节存储在最前面，也就是低地址处。
+ 小端法：最低有效字节存储在最前面。

大多数 Intel 兼容机采用小端模式，IBM 和 Sun 公司的机器大多数机器采用大端法。 对于很多新的处理器，支持双端法，可以配置成大端或者小端运行。例如基于 ARM 架构的处理器，支持双端法，但是 Android 系统和 iOS 系统却只能运行在小端模式。

**表示字符串**

C语言中的字符串被编码为以NULL字符结尾的字符数组，例如字符串“abcde”，这个字符串虽然只有5个字符，但是长度却为6，就是因为结尾字符的存在。

![f165e9159b9df2e276d0e088dbee39f](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\f165e9159b9df2e276d0e088dbee39f.png)

**C语言中的位级运算**

C语言中的一个特性就是支持按位进行布尔运算，确定一个位级表达式结果的最好方法，就是将十六进制扩展成二进制表示，然后按位进行相应的运算，最后再转换回十六进制。

C 表达式		 二进制表达 				二进制结果				 十六进制

 ∼ 0x41 		∼ [0100 0001]				 [1011 1110] 					0xBE

 ∼ 0x00 		∼ [0000 0000] 				[1111 1111] 					0xFF 

0x69 & 0x55 [0110 1001]&[0101 0101] 	[0100 0001]			 0x41 

0x69 | 0x55 [0110 1001]|[0101 0101]	 [0111 1101] 				0x7D

位运算一个常见的用法就是实现掩码运算，通俗点讲，通过位运算可以得到特定的 位序列。例如对于操作数 0x89ABCDEF，我们想要得到该操作数的最低有效字节的 值，可以通过 & 0xFF，这样我们就得到了最低有效字节 0x0000 00EF。

除了位级运算之外，C 语言还提供了一组逻辑运算，注意逻辑运算的运算符与位级 运算容易混淆。逻辑运算认为所有非零的参数都表示 true，只有参数 0 表示 false。

表达式		 			结果

 !0x41 						0x00 

!0x00 						0x01 

!!0x41			 			0x01 

0x69 && 0x55 		0x01 

0x69 || 0x55 				0x01 

对于 if(a && 5/a) 表达式，如果 a 等于 0，该逻辑运算的结果即为 false，不用再去 计算 5 除以 a，这样就可以避免了出现 5 除以 0 的情况。

### 整数的表示

**数值信息的表示**

有符号的二进制数的表示

十进制数有正负之分，那么二进制数也有正负之分。带有正、负号的二进制数称为 真值，例如 +1010110、-0110101 就是真值。为了方便运算，在计算机中约定: 在有 符号数的前面增加 1 位符号位，用 0 表示正号，用 1 表示负号。这种在计算机中用 0 和 1 表示正负号的数称为机器数。目前常用的机器数编码方法有源码、反码和补 码 3 种。

1 原码

• 正数的符号位用“0”表示，负数的符号位用“1”表示，其余数位表示数值本身。 

• 例如:X=+1010110, [X]原=01010110. 

• Y=-0110101, [Y]原=10110101.

原码的方法很简单，但是用原码表示的数在计算机中进行加减法运算很麻烦。比如遇到两个异号数相加或者两个同号数相减时，就要做减法。为了简化运算器的复杂性，提高运算速度，需要把减法做成加法运算，因此人们引入了反码和补码。

2 反码

• 正数的反码与其原码相同; 负数的反码是在原码的基础上保持符号位不变，其余 各位按位求反得到的。

 • 例如:X=+1010110, [X]反=[X]原=01010110. 

• Y=-0110101, [Y]原=10110101 [Y]反=11001010. .

3 补码

• 正数的补码与其原码相同; 负数的补码是在原码的基础上保持符号位不变，其它 的数位 1 变为 0，0 变为 1，最后再加 1 运算。也就是说，负数的补码是它的反码 加 1。在计算机中，有符号整数常常用补码形式存储5。

 • 例如:X=+1010110 [X]补=[X]反=[X]原=01010110. 

• Y=-0110101 [Y]原=10110101 [Y]补=11001011. 

• 对于任意一个数它的补码的补码是原码，即 [[X]补]补=[X]原.

**补码的意义**

我们该如何理解补码的意义?一般情况下我们有两种理解方法：

1  对于一个数:-5，其原码为 11012，此时最高位是符号位。若想找到其补码则需找 到与 +5 和为 100002 的二进制码，由于计算机中二进制是从右向左计算的，而我 们只有 4 个 bit，因此多出来的 1 会溢出以达到效果。+5 的原码为 01012，设-5 的补码为 10102，这两个相加是否可以实现上述结果? 答案是否定的，此时答案为 11112，还需要再加上 1，才能让答案归零。

2  仍以上文为例，我们可以知道 [-5]补=10112，此时最高位 1 不仅仅代表了负号， 也代表了 8，因此最高位代表-8，而其余两个 1 分别代表 +2，+1，这样我们仅通 过补码就可以直接知道它对应的十进制数字，甚至不需要知道它的原码!

bit有符号数范围

对于一个4bit的数据而言，补码所能表达的最小数字为：1000，即-8，在一个8bit的数据中，最小的数字为1000 0000，即-128，而最大的数为：0111 1111，即127，故上限为127，下限为-128，共255个数字，也即1个Byte的范围为：-128~127.

![image-20211216200853294](C:\Users\打死裤子\AppData\Roaming\Typora\typora-user-images\image-20211216200853294.png)

**有符号数和无符号数转换**

C语言允许数据类型之间做强制类型转换，例如代码示例，变量a是short类型，通过强制类型转换成无符号数，那么变量b的数值是多少呢？

```c
short int a = -12345;
unsigned short b = (unsigned short)a;
printf("a = %d,b = %u",a,b);
```

• -12345 经过强制类型转换后得到的无符号数是 53191, 从十进制的表示来看， 很难看出二者的关系，将十进制表示转换成二进制表示，可以发现二者的位模 式是一样的。

 • -12345: 1100 11111100 0111 

• 53191: 1100 11111100 0111

**相互转化**

1 有符号转无符号

用T2U来表示有符号数到无符号数的函数映射，当最高位
$$
X_{w-1}
$$
等于1时，此时有符号数表示一个负数，经过转换后，得到的无符号数等于该有符号数加上2**w;当最高位
$$
X_{w-1}
$$
等于0时，此时有符号数x表示一个非负数，得到的无符号数与有符号数是相等的。
$$
T2U_{w}(x)=\begin{cases} x+2^w,x<0\\ x,x>=0\end{cases}
$$
2 无符号转有符号

用U2T来表示无符号数到有符号数的函数映射。当前最高位等于0时，无符号数可以表示的数值小于有符号数的最大值，此时转换后的数值不变。当最高位等于1时，无符号数可以表示的数值大于有符号数的最大值，在这种情况下，转换后得到有符号数等于该无符号数减去2**w.
$$
U2T_{w}(u)=\begin{cases} u,u<=TMax_w\\
u-2^w,x>TMax_w\end{cases}
$$
**为什么要了解这个转换**

在C语言中，在执行一个运算时，如果一个运算数是有符号数，另一个运算数是无符号数，那么C语言会隐式的将有符号数强制转换成无符号数来执行运算。

```c
int i = -1;
unsigned int b = 0;
if(a<b)
	printf("-1<0")
else
	printf("-1>0")
```

• 输出-1>0，由于第二个操作数 b 是无符号数，第一个操作数 a 就隐式的转换成 无符号数，这个表达式实际上比较的是 4294967295(=2**32 − 1) < 0。

 • C 语言中将一个较小数据类型转换成较大的类型时，保持数值不变是可以的； 但大转小不行.

**扩展一个数字的位表示**

先来看一下把无符号数转换成一个更大的数据类型，例如，我们将一个 unsigned char 类型变量，转换成 unsigned short 类型。变量 a 占 8 个 bit 位，而变量 b 占 16 个 bit 位，对于无符号数的转换比较简单，只需要在扩展的数位进行补 0 即可，我 们将这种运算称为零扩展，具体表示如图所示。

![4aacf39ad983631543856b05244f626](C:\Users\打死裤子\Desktop\笔记\深入理解计算机系统\4aacf39ad983631543856b05244f626.png)

当有符号数表示非负数时，最高位是0，此时扩展的数位进行补零即可；当有符号数表示负数时，最高位是1，此时扩展的数位需要进行补1。

![image-20211216210141983](C:\Users\打死裤子\AppData\Roaming\Typora\typora-user-images\image-20211216210141983.png)

转换定理

当有符号数，从一个较小的数据类型转换成较大类型时，进行符号位扩展，可以保持数值不变。

**截断**

将int类型强制类型转换成short类型时，int类型高16位数据被丢弃，留下低16位的数据，因此截断一个数字，可能会改变它原来的数值。

无符号数：

将一个w位的无符号数，截断成k位时，丢弃最高的w-k位，截断操作可以对应于取模运算，即除以2的k次方之后得到的余数。

有符号数：

我们用无符号数的函数映射来解释底层的二进制位，这样一来我们就可以使用与 无符号数相同的截断方式，得到最低 K 位； 

 我们将第一步得到的无符号数转换成有符号数。

### 整数的运算

**无符号加法**

```c
unsigned char a = 255;
unsigned char b = 1;
unsigned char c = a+b;
printf("c=%d",c);
```

我们期望的结果为256，但实际结果为0.产生这个结果是因为a加b的和超过了unsigned char类型所能表示的最大值255.

**无符号数加法溢出**

在C语言执行的过程中，对于溢出的情况并不会报错，但是我们希望判定运算结果是否发生了溢出。

```c
int uadd_ok(unsigned x,unsigned y){
	unsigned sum = x+y;
	return sum >= x;
	//溢出返回0，没溢出返回1
}
```

因为x和y都是大于0的，因此，两者之和大于其中任何一个。

**补码加法溢出**

与无符号数相加不同的是，有符号数的溢出分为正溢出和负溢出。

当x加y的和大于等于2**（w-1）时，发生正溢出，此时，得到的结果会减去2的w次方。

当x加y的和小于-2**（w-1）时，发生负溢出，此时，得到的结果会加上2的w次方。

```c
char x = 127;
char y = 1;
char z = x+y;
printf("z = %d",z);
```

允行结果为-128，发生了正溢出。

**两种乘法**

无符号数乘法

w位的无符号数x和y，二者的乘积可能需要2w位来表示。在c语言中，定义了无符号数乘法所产生的结果是w位，因此，运行结果会截取2w位中的低w位。截断采用取模的方式，因此，运行结果等于x与y乘积并对2的w次方取模

补码乘法

计算机的有符号数用补码表示，因此补码乘法就是有符号数乘法。无论是无符号数乘法，还是补码乘法，运算结果的位级表示都是一样的，只不过补码乘法比无符号数乘法多一步，需要将无符号数转换成补码（有符号数）。虽然完整的乘积结果的位级表示可能会不同，但是截断后的位级表示都是相同的

其它一些情况，如果乘以的是2的整数倍，那么可以通过位移进行快速运算。

### 浮点数
